<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ISMRMRD: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ISMRMRD
   </div>
   <div id="projectbrief">ISMRM Raw Data Format</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">ISMRMRD Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="https://github.com/ismrmrd/ismrmrd/workflows/CMake/badge.svg?branch=master" alt="Build Status"/>
</div>
<h1>ISMRM Raw Data Format (<a class="el" href="namespace_i_s_m_r_m_r_d.html">ISMRMRD</a>)</h1>
<p>A prerequisite for sharing magnetic resonance (imaging) reconstruction algorithms and code is a common raw data format. This repository describes such a common raw data format, which attempts to capture the data fields that are required to describe the magnetic resonance experiment with enough detail to reconstruct images. The repository also contains a C/C++ library for working with the format. This standard was developed by a subcommittee of the ISMRM Sedona 2013 workshop and is described in detail in:</p>
<p>Inati SJ, Naegele JD, Zwart NR, Roopchansingh V, Lizak MJ, Hansen DC, Liu CY, Atkinson D, Kellman P, Kozerke S, Xue H, Campbell-Washburn AE, SÃ¸rensen TS, Hansen MS. ISMRM Raw data format: A proposed standard for MRI raw datasets. <a href="https://onlinelibrary.wiley.com/doi/10.1002/mrm.26089">Magn Reson Med. 2017 Jan;77(1):411-421.</a></p>
<p>Please cite this paper if you use the format.</p>
<h2>Build instructions</h2>
<p>The ISMRM Raw Data format is described by an XML schema and some C-style structs with fixed memory layout and as such does not have dependencies. However, it uses HDF5 files for storage and a C++ library for reading and writing the <a class="el" href="namespace_i_s_m_r_m_r_d.html">ISMRMRD</a> files is included in this distribution. Furthermore, since the XML header is defined with an XML schema, we encourage using XML data binding when writing software using the format. To compile all components of this distribution you need:</p>
<ul>
<li>HDF5 (version 1.8 or higher) libraries. Available from <a href="http://www.hdfgroup.org/downloads/index.html">http://www.hdfgroup.org/downloads/index.html</a>.</li>
<li>Boost (<a href="http://www.boost.org/">http://www.boost.org/</a>)</li>
<li>Cmake build tool (<a href="http://www.cmake.org/">http://www.cmake.org/</a>)</li>
<li>Git if you would like to use the source code archive (<a href="http://git-scm.com/">http://git-scm.com/</a>)</li>
<li>FFTW if you would like to compile some of the example applications (<a href="http://www.fftw.org">http://www.fftw.org</a>)</li>
<li>Doxygen if you would like to generate API documentation (<a href="http://www.doxygen.org">http://www.doxygen.org</a>)</li>
</ul>
<blockquote class="doxtable">
<p>It is only necessary to install the dependencies if you wish to develop compiled C/C++ software, which uses the <a class="el" href="namespace_i_s_m_r_m_r_d.html">ISMRMRD</a> format. The format can be read in Matlab or Python without installing any additional software. </p>
</blockquote>
<h3>Linux installation</h3>
<p>The dependencies mentioned above should be included in most linux distributions. On Ubuntu you can install all required dependencies with::</p>
<div class="fragment"><div class="line">sudo apt-get -y install doxygen git-core graphviz libboost-all-dev libfftw3-dev libhdf5-serial-dev</div></div><!-- fragment --><p>After installation of dependencies, the library can be installed with:</p>
<div class="fragment"><div class="line">git clone https://github.com/ismrmrd/ismrmrd</div><div class="line">cd ismrmrd/</div><div class="line">mkdir build</div><div class="line">cd build</div><div class="line">cmake ../</div><div class="line">make</div><div class="line">sudo make install</div></div><!-- fragment --><p>This will install the library in <code>/usr/local/</code> by default. To specify an alternative installation directory, pass <code>-D CMAKE_INSTALL_PREFIX=&lt;install dir&gt;</code> to <code>cmake</code>.</p>
<h1>Format Details</h1>
<p>The raw data format combines a mix of flexible data structures (XML header) and fixed structures (equivalent to C-structs). A raw data set consist mainly of 2 sections:</p>
<ol type="1">
<li>A flexible XML format document that can contain an arbitrary number of fields and accommodate everything from simple values (b-values, etc.) to entire vendor protocols, etc. This purpose of this XML document is to provide parameters that may be meaningful for some experiments but not for others. This XML format is defined by an XML Schema Definition file <a href="https://github.com/ismrmrd/ismrmrd/blob/master/schema/ismrmrd.xsd"><code>schema/ismrmrd.xsd</code></a>.</li>
<li>Raw data section. This section contains all the acquired data in the experiment. Each data item is preceded by a C-struct with encoding numbers, etc. Following this data header is a channel header and data for each acquired channel. The raw data headers are defined in a C/C++ header file <a href="https://github.com/ismrmrd/ismrmrd/blob/master/include/ismrmrd/ismrmrd.h"><code>ismrmrd.h</code></a></li>
</ol>
<p>In addition to these sections, the <a class="el" href="namespace_i_s_m_r_m_r_d.html">ISMRMRD</a> format also specifies an image header for storing reconstructed images and the accompanying C++ library provides a convenient way of writing such images into HDF5 files along with generic arrays for storing less well defined data structures, e.g. coil sensitivity maps or other calibration data.</p>
<h2>Flexible Data Header</h2>
<p>The flexible data structure is defined by the xml schema definition in <a href="https://github.com/ismrmrd/ismrmrd/blob/master/schema/ismrmrd.xsd"><code>schema/ismrmrd.xsd</code></a>. An example of an XML file for a Cartesian 3D acquisition can be found <a href="https://github.com/ismrmrd/ismrmrd/blob/master/schema/ismrmrd_example.xml"><code>schema/ismrmrd_example.xml</code></a></p>
<p>The most critical elements for image reconstruction are contained in the <code>&lt;encoding&gt;</code> section of the document, which describes the encoded spaced and also the target reconstructed space. Along with the <code>&lt;encodingLimits&gt;</code> this section allows the reconstruction program to determine matrix sizes, oversampling factors, partial Fourier, etc. In the example above, data is acquired with two-fold oversampling in the read-out (<code>x</code>) direction, which is reflected in the larger matrix size in the encoded space compared to the reconstruction space. The field of view is also twice as large in the encoded space. For the first phase encoding dimension (<code>y</code>), we have a combination of oversampling (20%), reduced phase resolution (only 83 lines of k-space acquired, and partial Fourier sampling, which is reflected in the asymmetric center of the encoding limits of the <code>&lt;kspace_encoding_step_1&gt;</code>. Specifically, the data lines would be placed into the encoding space like this:</p>
<div class="fragment"><div class="line">0                                     70                                         139</div><div class="line">|-------------------------------------|-------------------------------------------|</div><div class="line">                      ****************************************************</div><div class="line">                      ^               ^                                  ^</div><div class="line">                      0              28                                  83</div></div><!-- fragment --><p>After FFT, only the central 116 lines are kept, i.e. there is a reduced field of view in the phase encoding direction. Center and encoding limits for the readout dimension is not given in the XML header. This is to accommodate sequences where the center of the readout may change from readout to readout (alternating directions of readout). There is a field on the individual data headers (see below) to indicate the center of the readout.</p>
<p>An experiment can have multiple encoding spaces and it is possible to indicate on each acquired data readout, which encoding space the data belongs to (see below).</p>
<p>In addition to the defined field in the xml header, it is possible to add an arbitrary number of user defined parameters to accommodate special sequence parameters. Please consult the xml schema_ to see how user parameters are defined. Briefly, the XML header can have a section at the end which looks like:</p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">userParameters</span>&gt;</div><div class="line">  &lt;<span class="keywordtype">userParameterLong</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">name</span>&gt;<span class="keyword">MyVar1</span>&lt;/<span class="keywordtype">name</span>&gt;&lt;<span class="keywordtype">value</span>&gt;1003&lt;/<span class="keywordtype">value</span>&gt;</div><div class="line">  &lt;/<span class="keywordtype">userParameterLong</span>&gt;</div><div class="line">  &lt;<span class="keywordtype">userParameterLong</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">name</span>&gt;<span class="keyword">MyVar2</span>&lt;/<span class="keywordtype">name</span>&gt;&lt;<span class="keywordtype">value</span>&gt;1999&lt;/<span class="keywordtype">value</span>&gt;</div><div class="line">  &lt;/<span class="keywordtype">userParameterLong</span>&gt;</div><div class="line">  &lt;<span class="keywordtype">userParameterDouble</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">name</span>&gt;<span class="keyword">MyDoubleVar</span>&lt;/<span class="keywordtype">name</span>&gt;&lt;<span class="keywordtype">value</span>&gt;87.6676&lt;/<span class="keywordtype">value</span>&gt;</div><div class="line">  &lt;/<span class="keywordtype">userParameterDouble</span>&gt;</div><div class="line">&lt;/<span class="keywordtype">userParameters</span>&gt;</div></div><!-- fragment --><h2>Fixed Data structures</h2>
<p>Each raw data acquisition is preceded by the following fixed layout structures in <a href="https://github.com/ismrmrd/ismrmrd/blob/master/include/ismrmrd/ismrmrd.h#L225"><code>ismrmrd.h</code></a>.</p>
<p>The interpretation of some of these fields may vary from sequence to sequence, i.e. for a Cartesian sequence, <code>kspace_encode_step_1</code> would be the phase encoding step, for a spiral sequence where phase encoding direction does not make sense, it would be the spiral interleave number. The <code>encoding_space_ref</code> enables the user to tie an acquisition to a specific encoding space (see above) in case there are multiple, e.g. in situations where a calibration scan may be integrated in the acquisition.</p>
<p>The flags field is a bit mask, which in principle can be used freely by the user, but suggested flag values are given in <code><a class="el" href="ismrmrd_8h.html">ismrmrd.h</a></code>, it is recommended not to use already designated flag bits for custom purposes. There are a set of bits reserved for prototyping (bits 57-64), please see <code><a class="el" href="ismrmrd_8h.html">ismrmrd.h</a></code> for details.</p>
<p>The header contains a <code>trajectory_dimensions</code> field. If the value of this field is larger than 0, it means that trajectories are stored with each individual acquisition. For a 2D acquisition, the <code>trajectory_dimensions</code> would typically be 2 and the convention (for memory layout) is that the header is followed immediately by the trajectory before the complex data. There is an example of how this memory layout could be implemented with a C++ class in the <code><a class="el" href="ismrmrd_8h.html">ismrmrd.h</a></code> file:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Acquisition</div><div class="line">{</div><div class="line"></div><div class="line"><span class="comment">//....</span></div><div class="line"></div><div class="line">AcquisitionHeader head_; <span class="comment">//Header, see above</span></div><div class="line"></div><div class="line"><span class="keywordtype">float</span>* traj_;            <span class="comment">//Trajectory, elements = head_.trajectory_dimensions*head_.number_of_samples</span></div><div class="line">                        <span class="comment">//   [kx,ky,kx,ky.....]        (for head_.trajectory_dimensions = 2)</span></div><div class="line">                        <span class="comment">//   [kx,ky,kz,kx,ky,kz,.....] (for head_.trajectory_dimensions = 3)</span></div><div class="line"></div><div class="line"><span class="keywordtype">float</span>* data_;            <span class="comment">//Actual data, elements = head_.number_of_samples*head_.active_channels*2</span></div><div class="line">                        <span class="comment">//   [re,im,re,im,.....,re,im,re,im,.....,re,im,re,im,.....]</span></div><div class="line">                        <span class="comment">//    ---channel 1-------channel 2---------channel 3-----</span></div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>This suggested memory layout is only a suggestion. The HDF5 interface (see below) can be used to read the data into many different data structures. In fact, the user can choose to read only part of the header or not read the data, etc.</p>
<p>As mentioned above, the <a class="el" href="namespace_i_s_m_r_m_r_d.html">ISMRMRD</a> format also suggests a way to store reconstructed images (or maybe image data used for calibration). An <code>ImageHeader</code> structure is defined in <a href="https://github.com/ismrmrd/ismrmrd/blob/master/include/ismrmrd/ismrmrd.h#L286"><code>ismrmrd.h</code></a>.</p>
<p>In a similar fashion to the raw data acquisition data, the intention is to store a header followed by the image data. Since image data can be in several different format (e.g. float, complex, etc.), the memory layout is less well defined but can be described as:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>Image {</div><div class="line"></div><div class="line">ImageHeader head_;     <span class="comment">//ImageHeader as defined above</span></div><div class="line">T* data_;              <span class="comment">//Data, array of size (matrix_size[0]*matrix_size[1]*matrix_size[2]*channels),</span></div><div class="line">                        <span class="comment">//first spatial dimension is fastest changing array index, channels outer most (slowest changing).</span></div><div class="line">};</div></div><!-- fragment --><h2>File Storage</h2>
<p>The ISMRM Raw Data format is stored in <a href="https://www.hdfgroup.org/solutions/hdf5">HDF5 format</a>. Briefly it is a hierarchical data format (much like a file system), which can contain multiple variable organized in groups (like folders in a file system). The variables can contain arrays of data values, custom defined structs, or simple text fields. It is the convention (but not a requirement) that the <a class="el" href="namespace_i_s_m_r_m_r_d.html">ISMRMRD</a> datasets are stored in a group called <code>/dataset</code>. The XML configuration is stored in the variable <code>/dataset/xml</code> and the data is stored in <code>/dataset/data</code>. HDF5 files can be viewed with the HDFView application which is available on the HDF5 website for multiple platforms. Files can also be read directly in Matlab, in fact Matlab uses (since file format v7.3) HDF5 as its internal data format in the <code>.mat</code> files. As an example the data from an <a class="el" href="namespace_i_s_m_r_m_r_d.html">ISMRMRD</a> file with name <code>myfile.h5</code> can be read in matlab with a command like:</p>
<div class="fragment"><div class="line">&gt;&gt; data = h5read(&#39;simple_gre.h5&#39;, &#39;/dataset/data&#39;);</div><div class="line">&gt;&gt; data</div><div class="line"></div><div class="line">data =</div><div class="line"></div><div class="line">head: [1x1 struct]</div><div class="line">traj: {1x1281 cell}</div><div class="line">data: {1x1281 cell}</div><div class="line"></div><div class="line"> &gt;&gt; data.head</div><div class="line"></div><div class="line"> ans =</div><div class="line"></div><div class="line">                version: [1x1281 uint16]</div><div class="line">                  flags: [1x1281 uint64]</div><div class="line">        measurement_uid: [1x1281 uint32]</div><div class="line">           scan_counter: [1x1281 uint32]</div><div class="line"> acquisition_time_stamp: [1x1281 uint32]</div><div class="line">  physiology_time_stamp: [3x1281 uint32]</div><div class="line">      number_of_samples: [1x1281 uint16]</div><div class="line">     available_channels: [1x1281 uint16]</div><div class="line">        active_channels: [1x1281 uint16]</div><div class="line">           channel_mask: [16x1281 uint64]</div><div class="line">            discard_pre: [1x1281 uint16]</div><div class="line">           discard_post: [1x1281 uint16]</div><div class="line">          center_sample: [1x1281 uint16]</div><div class="line">     encoding_space_ref: [1x1281 uint16]</div><div class="line">  trajectory_dimensions: [1x1281 uint16]</div><div class="line">         sample_time_us: [1x1281 single]</div><div class="line">               position: [3x1281 single]</div><div class="line">               read_dir: [3x1281 single]</div><div class="line">              phase_dir: [3x1281 single]</div><div class="line">              slice_dir: [3x1281 single]</div><div class="line"> patient_table_position: [3x1281 single]</div><div class="line">                    idx: [1x1 struct]</div><div class="line">               user_int: [8x1281 int32]</div><div class="line">             user_float: [8x1281 single]</div><div class="line"></div><div class="line"> &gt;&gt;</div></div><!-- fragment --><p>The HDF5 file format can be accessed from C, C++, and java using the libraries provided on the HDF5 website. The <a class="el" href="namespace_i_s_m_r_m_r_d.html">ISMRMRD</a> distribution also comes with some C++ wrappers that can be used for easy access (read and write) from C++ programs. See below.</p>
<p>In addition to storing acquisition data and images as defined by the headers above, the HDF5 format also enables storage of generic multi-dimensional arrays. The <a class="el" href="namespace_i_s_m_r_m_r_d.html">ISMRMRD</a> format does not explicitly define how such data should be stored, but leaves it open for the user to add variables and data as dictated by a given application.</p>
<h2>C++ Support Library</h2>
<p>To enable easy prototyping of C++ software using the <a class="el" href="namespace_i_s_m_r_m_r_d.html">ISMRMRD</a> data format, a simple C++ wrapper class is provided (defined in <a href="https://github.com/ismrmrd/ismrmrd/blob/master/include/ismrmrd/dataset.h"><code>dataset.h</code></a>):</p>
<p>Using this wrapper, C++ applications can be programmed as:</p>
<div class="fragment"><div class="line"><span class="comment">// Open dataset</span></div><div class="line"><a class="code" href="class_i_s_m_r_m_r_d_1_1_dataset.html">ISMRMRD::Dataset</a> d(datafile.c_str(), <span class="stringliteral">&quot;dataset&quot;</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">std::string xml;</div><div class="line">d.readHeader(xml);</div><div class="line"><a class="code" href="struct_i_s_m_r_m_r_d_1_1_ismrmrd_header.html">ISMRMRD::IsmrmrdHeader</a> hdr;</div><div class="line">ISMRMRD::deserialize(xml.c_str(),hdr);</div><div class="line"></div><div class="line"><span class="comment">// Do something with the header</span></div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_acquisitions = d.getNumberOfAcquisitions();</div><div class="line"><a class="code" href="class_i_s_m_r_m_r_d_1_1_acquisition.html">ISMRMRD::Acquisition</a> acq;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; number_of_acquisitions; i++) {</div><div class="line">    <span class="comment">// Read one acquisition at a time</span></div><div class="line">    d.readAcquisition(i, acq);</div><div class="line"></div><div class="line">    <span class="comment">// Do something with the data</span></div><div class="line">}</div></div><!-- fragment --><p>Since the XML header is defined in the <code>schema/ismrmrd.xsd</code> file, it can be parsed with numerous xml parsing libraries. The <a class="el" href="namespace_i_s_m_r_m_r_d.html">ISMRMRD</a> library includes an API that allows for programmatically deserializing, manipulating, and serializing the XML header. See the code in the <a href="https://github.com/ismrmrd/ismrmrd/blob/master/utilities/"><code>utilities</code></a> directory for examples of how to use the XML API.</p>
<h2>C++ Example Applications</h2>
<p>The distribution includes two example applications, one that creates a simple 2D single-channel dataset from scratch and one that reconstructs this dataset (you need FFTW installed to compile these test applications). The data generation application can be found in <a href="https://github.com/ismrmrd/ismrmrd/blob/master/utilities/generate_cartesian_shepp_logan.cpp"><code>utilities/generate_cartesian_shepp_logan.cpp</code></a>:</p>
<p>To reconstruct this synthetic dataset, you can use the test reconstruction application <a href="https://github.com/ismrmrd/ismrmrd/blob/master/utilities/recon_cartesian_2d.cpp"><code>utilities/recon_cartesian_2d.cpp</code></a>:</p>
<h2>External use of <a class="el" href="namespace_i_s_m_r_m_r_d.html">ISMRMRD</a> C++ library in other projects</h2>
<p>To use <a class="el" href="namespace_i_s_m_r_m_r_d.html">ISMRMRD</a> for your externally developed projects, add the following to your CMakeLists.txt file:</p>
<div class="fragment"><div class="line">find_package( ISMRMRD REQUIRED )</div><div class="line">link_directories( ${ISMRMRD_LIBRARY_DIRS} )</div><div class="line">include_directories( ${ISMRMRD_INCLUDE_DIRS} )</div><div class="line">target_link_libraries( mytarget ${ISMRMRD_LIBRARIES} )</div></div><!-- fragment --><p>then when configuring your package use set the following cmake variables (command line variant shown):</p>
<div class="fragment"><div class="line">cmake -DISMRMRD_DIR:PATH=&lt;path to build/install tree of ISMRMRD&gt; &lt;path to my source tree&gt;</div></div><!-- fragment --><h2>Matlab Example Code and Datasets</h2>
<p>The <code>examples</code> folder contains some matlab code to illustrate simple interaction with the <a class="el" href="namespace_i_s_m_r_m_r_d.html">ISMRMRD</a> data format. Go to the <code>examples/data</code> folder and type the following to download the data::</p>
<div class="fragment"><div class="line">wget https://sourceforge.net/projects/ismrmrd/files/data/3D_partial_fourier.h5</div><div class="line">wget https://sourceforge.net/projects/ismrmrd/files/data/simple_gre.h5</div><div class="line">wget https://sourceforge.net/projects/ismrmrd/files/data/simple_spiral.h5</div></div><!-- fragment --><p>For instance, to reconstruct a 2D Cartesian acquisition (10 image repetitions), type (from the <code>examples/matlab</code> folder):</p>
<div class="fragment"><div class="line">&gt;&gt; images = simple_cartesian_recon(&#39;../data/simple_gre.h5&#39;);</div><div class="line">Reconstructing image 1....done</div><div class="line">Reconstructing image 2....done</div><div class="line">Reconstructing image 3....done</div><div class="line">Reconstructing image 4....done</div><div class="line">Reconstructing image 5....done</div><div class="line">Reconstructing image 6....done</div><div class="line">Reconstructing image 7....done</div><div class="line">Reconstructing image 8....done</div><div class="line">Reconstructing image 9....done</div><div class="line">Reconstructing image 10....done</div><div class="line">&gt;&gt;</div></div><!-- fragment --><p>You should see one of the reconstructed images display. An example is also given of a 3D acquisition with partial Fourier, phase and slice oversampling, etc. Reconstruct this dataset with:</p>
<div class="fragment"><div class="line">&gt;&gt; images = simple_cartesian_recon(&#39;../data/3D_partial_fourier.h5&#39;);</div><div class="line">Reconstructing image 1....done</div></div><!-- fragment --><p>The center slice of the volume should be displayed at the end of the reconstruction.</p>
<p>Finally, there is also a spiral dataset. This dataset illustrates how the flexible section of the <code>&lt;trajectoryDescription&gt;</code> can be used to add user defined parameters and an identifier to describe the trajectory. This dataset is also an example of storing the trajectory with the data for direct reconstruction. Reconstruct this dataset with:</p>
<div class="fragment"><div class="line">&gt;&gt; images = simple_spiral_recon(&#39;../data/simple_spiral.h5&#39;);</div><div class="line">Reconstructing image 1....done</div><div class="line">Reconstructing image 2....done</div><div class="line">Reconstructing image 3....done</div><div class="line">Reconstructing image 4....done</div><div class="line">Reconstructing image 5....done</div><div class="line">Reconstructing image 6....done</div><div class="line">Reconstructing image 7....done</div><div class="line">Reconstructing image 8....done</div><div class="line">Reconstructing image 9....done</div><div class="line">Reconstructing image 10....done</div><div class="line">&gt;&gt;</div></div><!-- fragment --><h2>Python implementation</h2>
<p>The Python implementation of the API is maintained in ## Other <a href="https://www.github.com/ismrmrd/ismrmrd-python">ismrmrd-python</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Feb 23 2021 00:27:10 for ISMRMRD by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
